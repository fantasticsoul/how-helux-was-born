import { isObj, noop } from '@helux/utils';
import { createDraft, finishDraft } from 'limu';
import type { Dict, IInnerSetStateOptions } from '../../types/base';
import { genRenderSN } from '../common/key';
import { runMiddlewares } from '../common/middleware';
import { emitDataChanged } from '../common/plugin';
import { IMutateCtx, newMutateCtx } from '../common/util';
import type { TInternal } from './buildInternal';
import { commitState } from './commitState';
import { handleOperate } from './operateState';

interface IPrepareDeepMutateOpts extends IInnerSetStateOptions {
  internal: TInternal;
  forAtom: boolean;
}

interface ICommitOpts extends IPrepareDeepMutateOpts {
  desc?: string;
  mutateCtx: IMutateCtx;
  state: any;
}

interface ISnCommitOpts extends ICommitOpts {
  sn: number;
}

/**
 * mutateNormal 和 mutateDepp 的 finishMutate 里提交之前可复用的公共逻辑
 */
export function beforeCommit(opts: ICommitOpts, innerSetOptions: IInnerSetStateOptions, draft: any) {
  Object.assign(opts, innerSetOptions);
  // sn 序号相同表示同一批次触发重渲染
  // 注意 sn 和 internal.ver 不能画等号，sn 对应的将要执行函数的会有很多（包括异步函数）
  // ver 只代表提交后的最新状态版本号
  opts.sn = opts.sn || genRenderSN();
  opts.from = opts.from || 'SetState';
  const { from, sn, desc, internal } = opts;
  internal.before({ from, draft, desc, sn });
  runMiddlewares(internal, draft, sn);
  return opts as ISnCommitOpts; // 已确保打上 sn 标记
}

/**
 * deep模式下，生成limu返回的草稿状态，用户可以对草稿做任意修改，且不会影响原状态
 */
export function prepareDeepMutate(opts: IPrepareDeepMutateOpts) {
  const { internal, desc } = opts;
  const mutateCtx = newMutateCtx(opts);
  const commitOpts = { state: {}, mutateCtx, ...opts, desc };
  const draft = createDraft(internal.rawState, {
    onOperate(opParams) {
      handleOperate(opParams, { internal, mutateCtx });
    },
  });

  return {
    draft,
    finishMutate(partial?: Dict, innerSetOptions: IInnerSetStateOptions = {}) {
      const { writeKeys, writeKeyPathInfo } = mutateCtx;
      // 把深依赖和浅依赖收集到的keys合并起来
      if (isObj(partial)) {
        // 触发 writeKeys 里记录当前变化key
        if (internal.forAtom) {
          draft.val = partial.val;
        } else {
          Object.keys(partial).forEach((key) => {
            draft[key] = partial[key];
          });
        }
      }
      const opts = beforeCommit(commitOpts, innerSetOptions, draft);

      mutateCtx.depKeys = Object.keys(writeKeys);
      opts.state = finishDraft(draft); // a structural shared obj generated by limu
      mutateCtx.triggerReasons = Object.values(writeKeyPathInfo);
      commitState(opts);
      emitDataChanged(internal, innerSetOptions, desc);

      /**
       * limu 的 immut 接口生成的可读代理对象虽然能总是同步最新的快照，但同步时机是在读取对象任意值那一刻
       * 用户修改完状态后直接使用 console.log(sharedState) 看到的会是旧值打印，其实已经是新值，
       * 需要继续向下读任意一个值即可刷新sharedState，这是再执行 console.log(sharedState) 看到的就是正确的
       * 为避免用户误会这是一个bug，这里提前随便读一个key，帮助用户主动刷新以下 sharedState 值
       */
      noop(internal.sharedState[mutateCtx.level1Key]);

      return internal.snap; // 返回最新的快照给调用者
    },
  };
}
